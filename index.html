<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Rainbow Smoke Rings – Dual Layer Fluid + Curtains (Bright)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
    color: #eee;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    padding: 8px 12px;
    background: rgba(0,0,0,0.6);
    border-radius: 8px;
    backdrop-filter: blur(6px);
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    z-index: 10;
  }
  #ui label {
    font-size: 12px;
  }
  #ui input[type="file"] {
    font-size: 12px;
  }
  #ui button {
    background: #222;
    border: 1px solid #444;
    color: #eee;
    padding: 4px 8px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
  }
  #ui button:hover { background: #333; }
  #brightness, #sensitivity {
    width: 100px;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<div id="ui">
  <label>
    Audio
    <input type="file" id="fileInput" accept="audio/*" />
  </label>
  <button id="useMic">Mic</button>
  <label>
    Brightness
    <input type="range" id="brightness" min="0.4" max="3.0" step="0.01" value="1.6">
  </label>
  <label>
    Sensitivity
    <input type="range" id="sensitivity" min="0.5" max="4.0" step="0.05" value="2.0">
  </label>
</div>

<canvas id="canvas"></canvas>
<audio id="audio" crossorigin="anonymous" style="display:none;"></audio>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  // Deep fluid layer (slow, heavy, bass only)
  const deepCanvas = document.createElement("canvas");
  const deepCtx = deepCanvas.getContext("2d");
  deepCanvas.width = width;
  deepCanvas.height = height;

  // Surface fluid layer (fast, sharp, all bands)
  const surfCanvas = document.createElement("canvas");
  const surfCtx = surfCanvas.getContext("2d");
  surfCanvas.width = width;
  surfCanvas.height = height;

  // Temp canvas for deep breathing transform
  const deepTempCanvas = document.createElement("canvas");
  const deepTempCtx = deepTempCanvas.getContext("2d");
  deepTempCanvas.width = width;
  deepTempCanvas.height = height;

  window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    deepCanvas.width = width;
    deepCanvas.height = height;
    surfCanvas.width = width;
    surfCanvas.height = height;
    deepTempCanvas.width = width;
    deepTempCanvas.height = height;
  });

  const audio = document.getElementById("audio");
  const fileInput = document.getElementById("fileInput");
  const useMicBtn = document.getElementById("useMic");
  const brightSlider = document.getElementById("brightness");
  const sensSlider = document.getElementById("sensitivity");

  let audioCtx = null;
  let analyser = null;
  let freqData = null;
  let source = null;

  let rings = [];
  let curtains = [];
  let globalHue = 0;

  // ------------ AUDIO ------------
  function initAudio() {
    if (!audioCtx)
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (!analyser) {
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      freqData = new Uint8Array(analyser.frequencyBinCount);
    }
  }

  function connectSource(node) {
    if (source) try { source.disconnect(); } catch(e){}
    source = node;
    source.connect(analyser);
    analyser.connect(audioCtx.destination);
  }

  fileInput.addEventListener("change", async e => {
    const f = e.target.files[0];
    if (!f) return;
    initAudio();
    audio.src = URL.createObjectURL(f);
    try {
      await audio.play();
      connectSource(audioCtx.createMediaElementSource(audio));
    } catch (err) {
      alert("Click the page once, then choose the file again.");
    }
  });

  useMicBtn.addEventListener("click", async () => {
    initAudio();
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      connectSource(audioCtx.createMediaStreamSource(stream));
    } catch (err) {
      alert("Mic access blocked.");
    }
  });

  document.body.addEventListener("click", () => {
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume();
    }
  });

  document.addEventListener("visibilitychange", () => {
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume();
    }
  });

  function getBands() {
    if (!analyser) return { bass: 0, mid: 0, high: 0 };
    analyser.getByteFrequencyData(freqData);

    const len = freqData.length;
    const bassEnd = Math.floor(len / 8);
    const midEnd  = Math.floor(len * 3 / 8);
    const highEnd = Math.floor(len * 7 / 8);

    let b = 0, m = 0, h = 0, bc = 0, mc = 0, hc = 0;
    for (let i = 0; i < len; i++) {
      const v = freqData[i] / 255;
      if (i < bassEnd) {
        b += v; bc++;
      } else if (i < midEnd) {
        m += v; mc++;
      } else if (i < highEnd) {
        h += v; hc++;
      }
    }
    return {
      bass: bc ? b / bc : 0,
      mid:  mc ? m / mc : 0,
      high: hc ? h / hc : 0
    };
  }

  // ------------ SMOKE RINGS ------------
  const MAX_RINGS = 260;

  function spawnRing(band, energy) {
    const sens = parseFloat(sensSlider.value);
    const e = Math.min(1, energy * sens);

    const side = Math.floor(Math.random() * 4); // 0=left,1=right,2=top,3=bottom
    let x, y, vx, vy;

    const speedBase = 80;
    const speedBoost = 420 * e;
    const speed = speedBase + speedBoost;

    if (side === 0) { // left
      x = -100;
      y = Math.random() * height;
      vx = speed;
      vy = (Math.random() - 0.5) * speed * 0.4;
    } else if (side === 1) { // right
      x = width + 100;
      y = Math.random() * height;
      vx = -speed;
      vy = (Math.random() - 0.5) * speed * 0.4;
    } else if (side === 2) { // top
      x = Math.random() * width;
      y = -100;
      vx = (Math.random() - 0.5) * speed * 0.4;
      vy = speed;
    } else { // bottom
      x = Math.random() * width;
      y = height + 100;
      vx = (Math.random() - 0.5) * speed * 0.4;
      vy = -speed;
    }

    const baseOuter = 40 + e * 80;
    const maxOuter  = baseOuter * (1.8 + Math.random() * 0.8);
    const thickness = 0.35 + Math.random() * 0.25;

    let baseHue;
    if (band === "bass") {
      baseHue = Math.random() < 0.5
        ? 10 + Math.random() * 45
        : 315 + Math.random() * 45;
    } else if (band === "mid") {
      baseHue = 100 + Math.random() * 80;
    } else {
      baseHue = 210 + Math.random() * 90;
    }

    const hue = (baseHue + globalHue) % 360;
    const brightness = parseFloat(brightSlider.value);

    rings.push({
      band,
      x, y,
      vx, vy,
      baseOuter,
      maxOuter,
      thickness,
      created: performance.now() / 1000,
      life: 2.5 + Math.random() * 3.0,
      hue,
      sat: 96,
      lightBase: 50 + (brightness - 1) * 18   // brighter base
    });

    if (rings.length > MAX_RINGS) {
      rings.splice(0, rings.length - MAX_RINGS);
    }
  }

  function updateAndDrawRings(dt) {
    const now = performance.now() / 1000;

    for (let i = rings.length - 1; i >= 0; i--) {
      const r = rings[i];
      const age = now - r.created;
      const t = age / r.life;

      if (t >= 1 ||
          r.x < -250 || r.x > width + 250 ||
          r.y < -250 || r.y > height + 250) {
        rings.splice(i, 1);
        continue;
      }

      // Move
      r.x += r.vx * dt;
      r.y += r.vy * dt;

      const ease = 1 - Math.pow(1 - t, 3);
      const outerRadius = r.baseOuter + (r.maxOuter - r.baseOuter) * ease;
      const innerRadius = outerRadius * (1 - r.thickness);

      const brightness = parseFloat(brightSlider.value);

      const alpha = (1 - t) * 0.95;                 // stronger alpha
      const innerLight = Math.min(96, r.lightBase + 18 * brightness);
      const midLight   = r.lightBase;
      const outerLight = Math.max(10, r.lightBase - 20);

      // Surface layer (all bands)
      const gradSurf = surfCtx.createRadialGradient(
        r.x, r.y, innerRadius * 0.35,
        r.x, r.y, outerRadius
      );

      gradSurf.addColorStop(0.0, `hsla(${r.hue}, ${r.sat}%, ${innerLight}%, ${alpha})`);
      gradSurf.addColorStop(0.35,`hsla(${r.hue}, ${r.sat}%, ${midLight}%, ${alpha * 0.95})`);
      gradSurf.addColorStop(0.7, `hsla(${r.hue}, ${r.sat}%, ${midLight}%, ${alpha * 0.6})`);
      gradSurf.addColorStop(1.0, `hsla(${r.hue}, ${r.sat}%, ${outerLight}%, 0)`);

      surfCtx.fillStyle = gradSurf;
      surfCtx.beginPath();
      surfCtx.arc(r.x, r.y, outerRadius, 0, Math.PI * 2);
      surfCtx.fill();

      // Deep bass memory
      if (r.band === "bass") {
        const deepAlpha = alpha * 0.7;

        const gradDeep = deepCtx.createRadialGradient(
          r.x, r.y, innerRadius * 0.5,
          r.x, r.y, outerRadius * 1.25
        );

        gradDeep.addColorStop(0.0, `hsla(${r.hue}, ${r.sat}%, ${midLight}%, 0)`);
        gradDeep.addColorStop(0.45,`hsla(${r.hue}, ${r.sat}%, ${midLight}%, ${deepAlpha})`);
        gradDeep.addColorStop(1.0, `hsla(${r.hue}, ${r.sat}%, ${outerLight}%, 0)`);

        deepCtx.fillStyle = gradDeep;
        deepCtx.beginPath();
        deepCtx.arc(r.x, r.y, outerRadius * 1.25, 0, Math.PI * 2);
        deepCtx.fill();
      }
    }
  }

  // ------------ SMOKED PARTICLE CURTAINS ------------
  const MAX_CURTAINS = 80;

  function spawnCurtain(band, energy) {
    const sens = parseFloat(sensSlider.value);
    const e = Math.min(1, energy * sens);
    if (e <= 0.02) return;

    const side = Math.random() < 0.5 ? "left" : "right";
    const y = Math.random() * height;
    const heightCurt = 140 + Math.random() * 260;
    const widthCurt  = width * (0.7 + Math.random() * 0.7);

    let x, vx;
    const speed = 25 + 150 * e;
    if (side === "left") {
      x = -widthCurt;
      vx = speed;
    } else {
      x = width + widthCurt;
      vx = -speed;
    }

    let baseHue;
    if (band === "mid") {
      baseHue = 100 + Math.random() * 80;  // greens / cyans
    } else {
      baseHue = 210 + Math.random() * 90;  // blues / violets
    }
    const hue = (baseHue + globalHue) % 360;
    const brightness = parseFloat(brightSlider.value);

    curtains.push({
      band,
      x,
      y,
      vx,
      width: widthCurt,
      height: heightCurt,
      created: performance.now() / 1000,
      life: 3.5 + Math.random() * 4.5,
      hue,
      sat: 90,
      lightBase: 50 + (brightness - 1) * 14,
      wobblePhase: Math.random() * Math.PI * 2
    });

    if (curtains.length > MAX_CURTAINS) {
      curtains.splice(0, curtains.length - MAX_CURTAINS);
    }
  }

  function updateAndDrawCurtains(dt) {
    const now = performance.now() / 1000;

    for (let i = curtains.length - 1; i >= 0; i--) {
      const c = curtains[i];
      const age = now - c.created;
      const t = age / c.life;

      if (t >= 1 ||
          c.x + c.width < -200 ||
          c.x > width + 200) {
        curtains.splice(i, 1);
        continue;
      }

      c.x += c.vx * dt;

      const wobble = Math.sin(now * 0.4 + c.wobblePhase) * 50;
      const yCenter = c.y + wobble;

      const brightness = parseFloat(brightSlider.value);

      const alpha = (1 - t) * 0.65;                  // brighter
      const innerLight = Math.min(96, c.lightBase + 16 * brightness);
      const outerLight = Math.max(8, c.lightBase - 18);

      const xStart = c.x;
      const xEnd   = c.x + c.width;

      const grad = surfCtx.createLinearGradient(xStart, yCenter, xEnd, yCenter);
      grad.addColorStop(0.0, `hsla(${c.hue}, ${c.sat}%, ${outerLight}%, 0)`);
      grad.addColorStop(0.25,`hsla(${c.hue}, ${c.sat}%, ${innerLight}%, ${alpha * 0.6})`);
      grad.addColorStop(0.7, `hsla(${c.hue}, ${c.sat}%, ${innerLight}%, ${alpha})`);
      grad.addColorStop(1.0, `hsla(${c.hue}, ${c.sat}%, ${outerLight}%, 0)`);

      surfCtx.fillStyle = grad;
      surfCtx.beginPath();
      surfCtx.rect(
        xStart,
        yCenter - c.height / 2,
        c.width,
        c.height
      );
      surfCtx.fill();
    }
  }

  // ------------ MAIN LOOP ------------
  let lastTime = performance.now() / 1000;
  let deepPhase = 0;

  function animate() {
    requestAnimationFrame(animate);

    const now = performance.now() / 1000;
    let dt = now - lastTime;
    if (dt > 0.05) dt = 0.05;
    lastTime = now;

    const { bass, mid, high } = getBands();
    const sens = parseFloat(sensSlider.value);
    const avgEnergy = (bass + mid + high) / 3 * sens;

    // Softer fading (to keep brightness)
    deepCtx.globalAlpha = 1;
    deepCtx.fillStyle = "rgba(0,0,0,0.015)";
    deepCtx.fillRect(0, 0, width, height);

    surfCtx.globalAlpha = 1;
    surfCtx.fillStyle = "rgba(0,0,0,0.05)";
    surfCtx.fillRect(0, 0, width, height);

    // Spawn rings
    function spawnBand(name, val, gain) {
      const e = val * sens;
      if (e <= 0.001) return;
      let spawnFloat = e * gain;
      let count = Math.floor(spawnFloat);
      if (Math.random() < (spawnFloat - count)) count++;
      for (let i = 0; i < count; i++) {
        spawnRing(name, val);
      }
    }

    spawnBand("bass", bass, 7.5);
    spawnBand("mid",  mid,  5.5);
    spawnBand("high", high, 4.5);

    // Spawn curtains from mid/high
    function spawnCurtainBand(name, val, gain) {
      const e = val * sens;
      if (e <= 0.01) return;
      let spawnFloat = e * gain;
      let count = Math.floor(spawnFloat);
      if (Math.random() < (spawnFloat - count)) count++;
      for (let i = 0; i < count; i++) {
        spawnCurtain(name, val);
      }
    }

    spawnCurtainBand("mid",  mid,  3.0);
    spawnCurtainBand("high", high, 2.2);

    // Draw curtains then rings on surface
    updateAndDrawCurtains(dt);
    updateAndDrawRings(dt);

    // Deep layer breathing
    deepPhase += dt * 0.15;
    const deepScale = 1.002 + 0.012 * Math.sin(deepPhase + avgEnergy * 3);

    deepTempCtx.clearRect(0, 0, width, height);
    deepTempCtx.drawImage(deepCanvas, 0, 0);
    deepCtx.save();
    deepCtx.setTransform(deepScale, 0, 0, deepScale,
                         width * (1 - deepScale) / 2,
                         height * (1 - deepScale) / 2);
    deepCtx.clearRect(0, 0, width, height);
    deepCtx.globalAlpha = 0.99;
    deepCtx.drawImage(deepTempCanvas, 0, 0);
    deepCtx.restore();
    deepCtx.setTransform(1,0,0,1,0,0);

    // Composite – slightly less black so colors pop
    ctx.globalAlpha = 1;
    ctx.fillStyle = "rgba(0,0,0,0.9)";
    ctx.fillRect(0, 0, width, height);
    ctx.drawImage(deepCanvas, 0, 0);
    ctx.drawImage(surfCanvas, 0, 0);

    globalHue = (globalHue + 0.10) % 360;
  }

  // Seed some rings + curtains
  (function seedDemo() {
    for (let i = 0; i < 10; i++) {
      spawnRing("bass", 0.4 + Math.random() * 0.3);
      spawnRing("mid",  0.3 + Math.random() * 0.4);
      spawnRing("high", 0.3 + Math.random() * 0.4);
    }
    for (let i = 0; i < 6; i++) {
      spawnCurtain("mid",  0.4 + Math.random() * 0.3);
      spawnCurtain("high", 0.4 + Math.random() * 0.3);
    }
  })();

  animate();
})();
</script>
</body>
</html>





